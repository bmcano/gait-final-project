from flask import Flask, render_template, request
import os
from datetime import datetime
from config import DEMO_MODE, MOCK_ITINERARIES, MOCK_VIDEOS, MOCK_WEATHER_INFO
from merge_videos import merge_clips_no_transition
from dotenv import load_dotenv
import time
from runwayml import RunwayML
import base64
import requests

app = Flask(__name__)

# Configurations
# These folders contain the images generated by AI
app.config['IMAGE_FOLDER'] = 'temp/images'
app.config['VIDEO_FOLDER'] = 'temp/video'

@app.route('/')
def index():
    """
    Landing page where users enter destination and travel dates.
    """
    return render_template('index.html')

@app.route('/itineraries', methods=['POST'])
def itineraries():
    """
    Page showing multiple itinerary options in horizontal cards.
    """
    # Extract user inputs
    destination = request.form['destination']
    description = request.form['description']
    from_date = request.form['fromDate']
    to_date = request.form['toDate']
    travel_dates = from_date + " to " + to_date

    # Parse dates and calculate trip duration
    try:
        from_date_obj = datetime.strptime(from_date, "%Y-%m-%d")
        to_date_obj = datetime.strptime(to_date, "%Y-%m-%d")
        trip_duration = (to_date_obj - from_date_obj).days + 1
    except ValueError:
        return "Invalid date format. Please ensure dates are in YYYY-MM-DD format."

    # TODO: Use destination and dates to call the weather API and retrieve weather info.
    # Store the result in `weather_info` and pass it to the frontend instead of MOCK_WEATHER_INFO.
    weather_info = MOCK_WEATHER_INFO

    # TODO: Use ChatGPT to dynamically generate itineraries using destination, dates, and weather info
    # Replace MOCK_ITINERARIES with actual data from ChatGPT's response.
    itineraries = MOCK_ITINERARIES

    # TODO: Get prompt from ChatGPT to generate images
    prompt = ''

    # TODO: Generate images based on the destination, itineraries, weather (e.g. snowy shot of user's travel destination)
    # Use the `generate_image` function below to create images for each itinerary.
    # For now, simulate generated images as placeholders.
    generated_images = generate_image(prompt=prompt, num_images=len(itineraries))

    # Pass mock or generated data to the template
    return render_template(
        'itineraries.html',
        destination=destination,
        from_date=from_date,
        to_date=to_date,
        travel_dates=travel_dates,
        trip_duration=trip_duration,
        itineraries=itineraries,  # Pass generated itineraries here
        images=generated_images  # Pass generated images to the frontend
    )

@app.route('/itinerary_details', methods=['POST'])
def itinerary_details():
    """
    Page showing detailed itinerary, weather, and packing suggestions.
    """
    # TODO: Extract all selected items, and then prepare them for ChatGPT to make the itinerary with
    selected_index = request.form.get('selected_indices', '')
    selected_indices = [int(idx) for idx in selected_index.split(',') if idx.isdigit()]
    selected_itineraries = [MOCK_ITINERARIES[idx] for idx in selected_indices]

    # TODO: Use ChatGPT to dynamically generate packing suggestions based on destination, weather, and itinerary.
    packing_list = ["Sunscreen", "Comfortable shoes", "Hat", "Reusable water bottle"]

    # Grab all selected images
    selected_images = request.form.get('selected_images', '').split(',')
    if DEMO_MODE:
        merged_video = [
            {"video": MOCK_VIDEOS[0]}
        ]
    else:
        # convert all selected items into videos
        index = 0
        generated_videos = []
        for image in selected_images:
            index += 1 
            video = generate_runway_video(image, "webp", f"video{1}.mp4")
            generated_videos.append(video)
        # merge all the videos together
        merged_video = [
            {"video": merge_clips_no_transition(generated_videos)}
        ]

    # Pass mock or generated data to the template
    return render_template(
        'itinerary_details.html',
        itinerary=selected_itineraries,
        weather=MOCK_WEATHER_INFO,  # Replace with dynamic weather_info once integrated
        packing_list=packing_list,
        video=merged_video
    )

# TODO: Define the generate_image function
# Use this function to integrate an AI image generation API (e.g., DALL-E, Stable Diffusion, etc.).
# Input: Key points of interest or landmarks from the itinerary.
# Output: Save generated images in app.config['IMAGE_FOLDER'] and return their file paths.
def generate_image(prompt, num_images=5):
    """
    Generate images using an AI image generation API.
    :param prompt: Text prompt for the image generation API.
    :param num_images: Number of images to generate.
    :return: List of file paths to the generated images.
    """
    # Example code structure:
    # 1. Call the image generation API with the prompt.
    # 2. Save the returned images to app.config['IMAGE_FOLDER'].
    # 3. Return the list of file path.

def generate_runway_video(image_path, image_tpye, output_filename):
    """
    Generate a drone-like hovering video from an input image using the Replicate API.
    :image_path: The file path to the image to convert to a video 
    :output_filename: The name of the temporary output video
    """
    if DEMO_MODE:
        print("using file in DEMO_MODE")
        return

    client = RunwayML()
    print("start")
    # Create a new image-to-video task using the "gen3a_turbo" model
    base64_image = encode_image_to_base64(image_path)
    task = client.image_to_video.create(
        model='gen3a_turbo',
        # Point this at your own image file
        prompt_image=f"data:image/{image_tpye};base64,{base64_image}",
        prompt_text='Drone-like hovering movement of the given scene',
        duration=5
    )
    task_id = task.id

    # Poll the task until it's complete
    time.sleep(10)
    task = client.tasks.retrieve(task_id)
    while task.status not in ['SUCCEEDED', 'FAILED']:
        time.sleep(10)
        task = client.tasks.retrieve(task_id)

    print('Task complete:', task)
    save_video(task.output[0], output_filename)
    return output_filename

"""
Helper functions relating to video generation 
"""
def encode_image_to_base64(image_path):
    with open(image_path, "rb") as image_file:
        encoded_string = base64.b64encode(image_file.read()).decode("utf-8")
    return encoded_string

def save_video(video_url, output_filename):
    # Send a GET request to the video URL
    response = requests.get(video_url, stream=True)
    # Check if the request was successful
    if response.status_code == 200:
        # Open a file in binary write mode and save the video content
        with open(f"temp/video/{output_filename}.mp4", "wb") as video_file:
            for chunk in response.iter_content(chunk_size=8192):
                video_file.write(chunk)
        print("Video saved.")
    else:
        print(f"Failed to save video. Status code: {response.status_code}, Error: {response.text}")


if __name__ == '__main__':
    # Ensure required directories exist
    os.makedirs(app.config['IMAGE_FOLDER'], exist_ok=True)
    os.makedirs(app.config['VIDEO_FOLDER'], exist_ok=True)
    load_dotenv()
    app.run(debug=True)
